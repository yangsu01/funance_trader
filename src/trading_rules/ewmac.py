import pandas as pd
from typing import Dict, Optional
import statsmodels.api as sm
import numpy as np

from .trading_rule import TradingRule
from .indicators import EWMA

class EWMACRule(TradingRule):
    def __init__(
        self,
        short_window: int,
        long_window: int,
        scale_window: int=60,
        ols_window: Optional[int]=None,
        vol_window: int=36
    ):
        """Initializes EWMACRule

        Args:
            short_window (int): short window for EWMA
            long_window (int): long window for EWMA
            scale_window (int, optional): window for scaling forecast. Defaults to 60.
            ols_window (Optional[int], optional): window for OLS regression. Defaults to None.
        """
        self.short_window = short_window
        self.long_window = long_window
        self.scale_window = scale_window
        self.raw_forecasts = pd.Series(dtype=float)
        self.forecasts = pd.Series(dtype=float)
        self.returns_history = pd.Series(dtype=float)
        self.short_ewma = EWMA(short_window)
        self.long_ewma = EWMA(long_window)
        self.ols_window = ols_window
        self.last_price = None
        self.ols_coefficient = 1.0
        self.vol_window = vol_window
        self.vol_ewma = EWMA(vol_window)
        
    
    def _normalize_vol(self, forecast: float, price_vol: float) -> float:
        """Normalizes forecast by dividing by recent price volatility

        Args:
            forecast (float): raw forecast generated by EWMACRule
            price_vol (float): recent price volatility

        Returns:
            float: normalized forecast
        """
        # if recent price volatility is too low, return 0
        if price_vol < 1e-3:
            return 0.0
        
        return forecast / price_vol

    def _ols_coefficient(self) -> float:
        """Fits OLS regression to raw forecasts and returns the coefficient.
        Regresses next day's returns on current day's forecast to find predictive relationship.

        Returns:
            float: OLS coefficient used to scale forecast. Returns 0.0 if not enough data
                    to avoid adjusting positions.
        """
        # Align raw forecasts with next day's returns
        df = pd.concat(
            [self.raw_forecasts, self.returns_history.shift(-1)],
            axis=1,
            join='inner'
        ).dropna()
        df.columns = ['forecast', 'returns']
        
        # check if enough data
        if len(df) < self.ols_window:
            return 0.0 # avoid adjusting positions
        
        # Use most recent window of data
        window_data = df.iloc[-self.ols_window:]
        X = sm.add_constant(window_data['forecast'])
        y = window_data['returns']
        model = sm.OLS(y, X).fit()
        
        # Get coefficient for forecast term
        beta = model.params['forecast']
        
        # Scale beta by ratio of standard deviations to get coefficient in forecast units
        scaled_beta = beta * window_data['forecast'].std() / window_data['returns'].std()
        
        self.ols_coefficient = scaled_beta
        
        return scaled_beta
        
        
    def _scale_forecast(
        self,
        forecast: float,
        lower_bound: float=-20,
        upper_bound: float=20
    ) -> float:
        """Scales forecast to target range while maintaining average absolute value of 10
        
        Args:
            forecast (float): raw forecast generated by EWMACRule
            lower_bound (float, optional): lower bound for scaled forecast. Defaults to -20.
            upper_bound (float, optional): upper bound for scaled forecast. Defaults to 20.

        Returns:
            float: scaled forecast
        """

        if len(self.raw_forecasts) < self.scale_window:
            return 0.0
            
        # Calculate and store forecast scalar
        recent_forecasts = self.raw_forecasts.iloc[-self.scale_window:]
        avg_abs_forecast = recent_forecasts.abs().mean()
        
        if avg_abs_forecast < 1e-6:
            return 0.0
            
        # Calculate and store current scalar    
        current_scalar = 10.0 / (avg_abs_forecast*self.ols_coefficient)
        
        # Scale forecast using current scalar
        scaled = forecast * current_scalar
        
        # Cap at bounds
        return np.clip(scaled, lower_bound, upper_bound)


    def generate_next_forecast(self, data: pd.Series) -> Dict[str, float]:
        """Generates forecast for given data. Meant to be used one step at a time.

        Args:
            data (pd.Series): historical prices for a single day. should have a 'Close' column.
        Returns:
            Dict[str, float]: dictionary of ticker and forecast
        """
        price = data['Close'].iloc[0]
        timestamp = data.name
        ticker = data['Close'].index[0]

        # calculate returns for current day
        if self.last_price is not None:
            returns = (price - self.last_price) / self.last_price
            price_var = self.vol_ewma.update(returns**2, timestamp)
            price_vol = np.sqrt(price_var)
            self.returns_history.loc[timestamp] = returns

        self.last_price = price
        
        # update EWMAs with new data
        short_ewma = self.short_ewma.update(price, timestamp)
        long_ewma = self.long_ewma.update(price, timestamp)
        
        # if not enough data for EWMA, return 0
        if not self.long_ewma.check_enough_data() or not self.vol_ewma.check_enough_data():
            return {ticker: 0.0}
        
        raw_forecast = short_ewma - long_ewma
        
        # divide by recent volatility to standardize 
        raw_forecast = self._normalize_vol(raw_forecast, price_vol)
        
        # save raw forecast
        self.raw_forecasts.loc[timestamp] = raw_forecast
        
        # if given ols window, update ols forecast
        if self.ols_window:
            raw_forecast = self._ols_coefficient() * raw_forecast
            
        # Scale the forecast (whether OLS adjusted or not)
        scaled_forecast = self._scale_forecast(raw_forecast)
            
        # Only save scaled forecast if we have enough data
        if len(self.raw_forecasts) >= self.scale_window:
            self.forecasts.loc[timestamp] = scaled_forecast
                
        return {ticker: scaled_forecast}
    

    def generate_forecasts(self, data: pd.DataFrame) -> pd.Series:
        """Generates forecasts for historical price data.

        Args:
            data (pd.DataFrame): historical price data with 'Close' column
        Returns:
            pd.Series: series of scaled forecasts between -20 and 20
        """
        # Reset any existing states
        self.raw_forecasts = pd.Series(dtype=float)
        self.forecasts = pd.Series(dtype=float)
        self.returns_history = pd.Series(dtype=float)
        self.short_ewma = EWMA(self.short_window)
        self.long_ewma = EWMA(self.long_window)
        self.last_price = None
        self.ols_coefficient = 1.0
        self.vol_ewma = EWMA(self.vol_window)

        # Generate forecasts for each date
        for _, row in data.iterrows():
            self.generate_next_forecast(row)

        return self.forecasts
        
    
    def get_plot_data(self) -> Dict[str, pd.Series]:
        """Returns historical EWMA values for plotting

        Returns:
            Dict[str, pd.Series]: dictionary of historical EWMA values
        """
        return {
            f'{self.short_window} Day EWMA': self.short_ewma.get_history(),
            f'{self.long_window} Day EWMA': self.long_ewma.get_history()
        }

    
    def get_forecasts(self) -> pd.Series:
        """Returns historical scaled forecasts

        Returns:
            pd.Series: historical forecasts
        """
        return self.forecasts
    

    def get_raw_forecasts(self) -> pd.Series:
        """Returns historical raw forecasts

        Returns:
            pd.Series: historical raw forecasts
        """
        return self.raw_forecasts
    
    def get_vol_history(self) -> pd.Series:
        """Returns historical volatility

        Returns:
            pd.Series: historical volatility
        """
        return self.vol_ewma.get_history()
